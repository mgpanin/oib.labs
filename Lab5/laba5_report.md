# Цель работы

Изучение механизмов изменения идентификаторов, применения SetUID- и Sticky-битов. Получение практических навыков работы в консоли с дополнительными атрибутами. Рассмотрение работы механизма смены идентификатора процессов пользователей, а также влияние бита Sticky на запись и удаление файлов

# Выполнение лабораторной работы

1. Установим компилятор gcc (Рис. 1)
   ![рис.1.](111.png)

2. Создадим программу simpleid.c (Рис. 2)

   ![рис.2.](222.png)

3. 1)	Скомпилируем программу (Рис. 3)
	gcc simpleid.c –o simpleid
	2)	Выполним програму simpleid (Рис. 3)
	./simpleid
	Выполним системную программу id (Рис. 3)
	id
   ![рис.3.](33.png)

4. Результаты совпадают
	Усложним программу, добавив вывод действительных идентификаторов, сохранив как simpleid2.c (Рис. 4)

   ![рис.4.](444.png)

5. Скомпилируем и запустим simpleid2.c (Рис. 5)
	gcc simpleid2.c –o simpleid
	./simpleid2
	От имени суперпользователя выполним команды (Рис. 5)
	hown root:guest /home/guest/simpleid2
	chmod u+s /home/guest/simpleid2
	С помощью этих команд файлу simpleid2 изменяем владельца и группу на root и guest соответственно, а также устанавливаем на файл SetUID-бит
	Выполним проверку правильности установки новых атрибутов и смены владельца файла simpleid2 (Рис. 5)
	ls –l simpleid2
	Запустим simpleid2 и id (Рис. 5)
	./simpleid2
	id
   ![рис.5.](555.png)

6. 	Результаты также одинаковы
	Проделаем тоже самое относительно SetGID-бита (Рис. 6)
   ![рис.6.](666.png)

7. Создадим readfile.c (Рис. 7)
   ![рис.7.](777.png)

8. Откомпилируем ее (Рис. 8)
	gcc readfile.c –o readfile
	Сменим владельца у файла readfile.c и изменим права так, чтобы только root мог прочитать его (Рис. 8)
	Проверим, что пользователь guest не может прочитать файл readfile.c (Рис. 8)
	Сменим у программы readfile владельца и установим SetUID-бит (Рис. 8)

   ![рис.8.](888.png)

9. Проверим, может ли программа readfile прочитать файл readfile.c (Рис. 9)
   ![рис.9.](999.png)
   
10. Проверим, может ли программа readfile прочитать файл /etc/shadow (Рис. 10)
   ![рис.10.](101010.png)
 
 
11. Выясним, установлен ли атрибут Sticky на директории /tmp (Рис. 11)
	ls –l / | grep tmp
	От имени пользователя guest создайте файл file01.txt в директории /tmp со словом test (Рис. 11)
	echo “test” > /tmp/file01.txt
	Просмотрим атрибуты у только что созданного файла и разрешим чтение и запись для категории пользователей «все остальные» (Рис. 11)
	ls –l /tmp/file01.txt
	chmod o+rw /tmp/file01.txt
	ls –l /tmp/file01.txt

   ![рис.11.](111111.png)

12. От пользователя guest2 (не являющегося владельцем) попробуйте прочитать файл /tmp/file01.txt (Рис. 12)
	cat /tmp/file01.txt
	От пользователей guest2 попробуем дозаписать в файл /tmp/file01.txt слово test2 (Рис. 12)
	echo “test2” > /tmp/file01.txt
	Дозаписать не получилось
	Проверим содержимое файла (Рис. 12)
	cat /tmp/file01.txt
	От пользователей guest2 попробуем записать в файл /tmp/file01.txt слово test3, стерев всю информацию в файле (Рис. 12)
	echo “test3” > /tmp/file01.txt
	Перезаписать информацию получилось
	Проверим содержимое файла (Рис. 12)
	cat /tmp/file01.txt
	От пользователя guest2 попробуйте удалить файл /tmp/file01.txt (Рис. 12)
	rm /tmp/file01.txt
	Файл не удалился
	Повысим свои права до суперпользователя (Рис. 12)
	su –
	И выполним после этого команду снимающую атрибут Sticky-бита с директории /tmp
	chmod –t /tmp
	Покинем режим суперпользователя (Рис. 12)
	exit
	От пользователя guest2 проверим, что атрибут t у директории /tmp нет (Рис. 12)
	ls –l / | grep tmp
	Повторим предыдущие шаги (Рис. 12)
	Файл удалось удалить от имени пользователя, не являющегося его владельцем

   ![рис.12.](121212.png)
   
13. Повысим свои права до суперпользователя и вернем атрибут t на директорию /tmp (Рис. 13)
	su -
	chmod +t /tmp
	exit

   ![рис.13.](131313.png)

# Выводы

Я изучил механизмы изменения идентификаторов, применения SetUID- и Sticky-битов, получил практические навыки работы в консоли с дополнительными атрибутами, а также рассмотрели работы механизма смены идентификатора процессов пользователей и влияние бита Sticky на запись и удаление файлов

